use aiken/collection/list.{at, drop, foldl, head, take}
use aiken/crypto/bitwise.{State}
use aiken/crypto/bls12_381/g1.{add as addG1, scale as scaleG1, zero}
use aiken/crypto/bls12_381/g2.{generator as generatorG2}
use aiken/crypto/bls12_381/scalar.{
  Scalar, add, from_int, mul, neg, recip, scale, sub,
}
use inner_product.{inner_product}
use lagrange.{lagrange_polynomial_basis}
use omega_rotations.{rotate_omegas, rotate_omega, powers}
use transcript.{
  common_scalar, construct_transcript, read_point, read_scalar,
  squeeze_challenge,
}
use verifier_key.{barycentric_weight, blinding_factors, omega, omega_inv, g2_const, {{{F_IMPORTS}}}, {{{P_IMPORTS}}} }
use halo2_kzg.{build_msm, eval}
use aiken/crypto/bls12_381/pairing.{miller_loop, final_exponentiation}

pub fn verifier(proof: Data, transcript_rep: State<Scalar>, {{{PUBLIC_INPUTS_NAMES}}}) -> Bool {

    let rotations_for_vanishing =
        rotate_omegas(omega, omega_inv, -(blinding_factors + 1), 0)

    let scalarZero = from_int(0)
    let scalarOne = from_int(1)
    let scalarDelta = from_int(0x08634d0aa021aaf843cab354fabb0062f6502437c6a09c006c083479590189d7)

    let inputs_count = from_int({{{PUBLIC_INPUTS_COUNT}}})

    let transcript = construct_transcript(proof, transcript_rep)
    let transcript = common_scalar(inputs_count, transcript)

{{{PUBLIC_INPUTS}}}

{{{PES}}}


    let n = {{X_EXPONENT}}
    let xn = scale( x, n)

    let x_prev = rotate_omega(omega, omega_inv, x, (-1))
    let x_current = rotate_omega(omega, omega_inv, x, 0)
    let x_next = rotate_omega(omega, omega_inv, x, 1)
    let x_last = rotate_omega(omega, omega_inv, x, (-(blinding_factors + 1)))

    let evaluations_of_lagrange_polynomial =
        lagrange_polynomial_basis(
        x,
        xn,
        barycentric_weight,
        rotations_for_vanishing,
        )
    expect Some(last_evaluation) = head(evaluations_of_lagrange_polynomial)
    let evaluation_for_blinding_factors =
        take(drop(evaluations_of_lagrange_polynomial, 1), blinding_factors)
    let sum_of_evaluation_for_blinding_factors =
        foldl(
        evaluation_for_blinding_factors,
        scalarZero,
        fn(e, acc) { add(e, acc) },
        )
    expect Some(evaluation_at_0) =
        at(evaluations_of_lagrange_polynomial, 1 + blinding_factors)
    let active_rows =
        sub(scalarOne, add(last_evaluation, sum_of_evaluation_for_blinding_factors))
    // -----------------------------------------------------------------------------------------------

    let rotations_for_instances = rotate_omegas(omega, omega_inv, 0, {{{PUBLIC_INPUTS_COUNT}}})
    let lagrange_polynomial_instances = lagrange_polynomial_basis( x, xn, barycentric_weight, rotations_for_instances)
    let instance_eval_1 = inner_product(lagrange_polynomial_instances, [{{{PUBLIC_INPUTS_LAGRANGE}}}])

{{{GATES}}}

{{{LOOKUP_TABLES_EXPRESSIONS}}}

{{{LOOKUP_INPUTS_EXPRESSIONS}}}

{{{LOOKUPS}}}

{{{PERMUTATIONS_EVALS}}}

{{{PERMUTATIONS_LHS}}}

{{{LHS_SETS}}}

{{{PERMUTATIONS_RHS}}}

{{{RHS_SETS}}}

{{{PERMUTATIONS_COMBINED}}}

//      expressions for vanishing polynomial
{{{VANISHING_EXPRESSIONS}}}

{{{VANISHING_EVALUATION}}}

    expect Some(inverted) = recip(sub(xn, scalarOne)) // recip is inverse of the number mod bls12_381_field_prime
    let vanishing_s = mul(hEval, inverted)

    // vanishing split IS PASSED IN REVERSE ORDER!!!
    // this is MSM done for h-commitments
{{{H_COMMITMENTS}}}

{{{COMMITMENT_MAP}}}

{{{POINT_SETS}}}

      // left and s_g2
      // right and g2
      // g2 is not negated as bls12_381_finalVerify is doing negation
      let g2 = generatorG2

      let x1Powers = powers({{{X1_POWERS_COUNT}}}, x1)
      let x4Powers = powers({{{X4_POWERS_COUNT}}}, x4)

    trace @"vanishing_s": vanishing_s
    trace @"vanishing_g": vanishing_g

    trace @"vanishing_rand": vanishing_rand
    trace @"random_eval": random_eval

      let alt_right =
          build_msm(
              x1Powers,
              x2,
              x3,
              x4Powers,
              f_commitment,
              pi_term,
              [{{{Q_EVALS_FROM_PROOF}}}],
              commitment_data,
              point_sets)


      let el = pi_term
      let er = eval(alt_right)

      let ml_l = miller_loop(el, g2_const)
      let ml_r = miller_loop(er, g2)

      final_exponentiation(ml_l, ml_r)
}

// this test generates random input data for verifier
test integration_test() {
    expect {{{TEST_CALL}}} == True
}
