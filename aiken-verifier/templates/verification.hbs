use aiken/crypto/bitwise.{State}
use aiken/crypto/bls12_381/scalar.{
Scalar, add, from_int, mul, neg, sub,
}
use transcript.{
common_scalar, construct_transcript, read_point, read_scalar,
squeeze_challenge,
}

pub fn verifier(proof: Data, transcript_rep: State<Scalar>, {{{PUBLIC_INPUTS_NAMES}}}) -> Bool {

    // todo for now those are set as constants to check if other parts compiles and works as expected
    let evaluation_at_0 = from_int(1)
    let last_evaluation = from_int(2)
    let active_rows = from_int(3)
    // -----------------------------------------------------------------------------------------------

    let scalarZero = from_int(0)
    let scalarOne = from_int(1)

    let x_exponent = {{{X_EXPONENT}}}

    let inputs_count = from_int({{{PUBLIC_INPUTS_COUNT}}})

    let transcript = construct_transcript(proof, transcript_rep)
    let transcript = common_scalar(inputs_count, transcript)

{{{PUBLIC_INPUTS}}}

{{{PES}}}

{{{GATES}}}

{{{LOOKUP_TABLES_EXPRESSIONS}}}

{{{LOOKUP_INPUTS_EXPRESSIONS}}}

{{{LOOKUPS}}}

    True
}
