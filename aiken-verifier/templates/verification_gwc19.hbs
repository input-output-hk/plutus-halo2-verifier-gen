use aiken/builtin.{bls12_381_g1_neg}
use aiken/collection/list.{at, drop, foldl, head, take}
use aiken/crypto/bitwise.{State}
use aiken/crypto/bls12_381/g1.{scale as scaleG1, zero, generator as generatorG1}
use aiken/crypto/bls12_381/g2.{generator as generatorG2}
use aiken/crypto/bls12_381/scalar.{
  Scalar, add, from_int, mul, neg, scale, sub
}
use bls_utils.{inner_product, recip_eea, addG1}
use lagrange.{lagrange_polynomial_basis}
use omega_rotations.{rotate_omegas, rotate_omega}
use transcript.{
  common_scalar, construct_transcript, read_point, read_scalar,
  squeeze_challenge,
}
use verifier_key.{barycentric_weight, blinding_factors, omega, omega_inv, g2_const, {{{F_IMPORTS}}}, {{{P_IMPORTS}}} }
use halo2_kzg.{eval, MSM, MSMElement}
use aiken/crypto/bls12_381/pairing.{miller_loop, final_exponentiation}

pub fn verifier(proof: Data, transcript_rep: State<Scalar>, {{{PUBLIC_INPUTS_NAMES}}}) -> Bool {

    let rotations_for_vanishing =
        rotate_omegas(omega, omega_inv, -(blinding_factors + 1), 0)

    let scalarZero = from_int(0)
    let scalarOne = from_int(1)
    let scalarDelta = from_int(0x08634d0aa021aaf843cab354fabb0062f6502437c6a09c006c083479590189d7)

    let inputs_count = from_int({{{PUBLIC_INPUTS_COUNT}}})

    let transcript = construct_transcript(proof, transcript_rep)
    let transcript = common_scalar(inputs_count, transcript)

{{{PUBLIC_INPUTS}}}

{{{PES}}}


    let n = {{X_EXPONENT}}
    let xn = scale( x, n)

    let x_prev = rotate_omega(omega, omega_inv, x, (-1))
    let x_current = rotate_omega(omega, omega_inv, x, 0)
    let x_next = rotate_omega(omega, omega_inv, x, 1)
    let x_last = rotate_omega(omega, omega_inv, x, (-(blinding_factors + 1)))

    let evaluations_of_lagrange_polynomial =
        lagrange_polynomial_basis(
        x,
        xn,
        barycentric_weight,
        rotations_for_vanishing,
        )
    expect Some(last_evaluation) = head(evaluations_of_lagrange_polynomial)
    let evaluation_for_blinding_factors =
        take(drop(evaluations_of_lagrange_polynomial, 1), blinding_factors)
    let sum_of_evaluation_for_blinding_factors =
        foldl(
        evaluation_for_blinding_factors,
        scalarZero,
        fn(e, acc) { add(e, acc) },
        )
    expect Some(evaluation_at_0) =
        at(evaluations_of_lagrange_polynomial, 1 + blinding_factors)
    let active_rows =
        sub(scalarOne, add(last_evaluation, sum_of_evaluation_for_blinding_factors))
    // -----------------------------------------------------------------------------------------------

    let rotations_for_instances = rotate_omegas(omega, omega_inv, 0, {{{PUBLIC_INPUTS_COUNT}}})
    let lagrange_polynomial_instances = lagrange_polynomial_basis( x, xn, barycentric_weight, rotations_for_instances)
    let instance_eval_1 = inner_product(lagrange_polynomial_instances, [{{{PUBLIC_INPUTS_LAGRANGE}}}])

{{{GATES}}}

{{{LOOKUP_TABLES_EXPRESSIONS}}}

{{{LOOKUP_INPUTS_EXPRESSIONS}}}

{{{LOOKUPS}}}

{{{PERMUTATIONS_EVALS}}}

{{{PERMUTATIONS_LHS}}}

{{{LHS_SETS}}}

{{{PERMUTATIONS_RHS}}}

{{{RHS_SETS}}}

{{{PERMUTATIONS_COMBINED}}}

//      expressions for vanishing polynomial
{{{VANISHING_EXPRESSIONS}}}

{{{VANISHING_EVALUATION}}}

    let inverted = recip_eea(sub(xn, scalarOne)) // recip is inverse of the number mod bls12_381_field_prime
    let vanishing_s = mul(hEval, inverted)

    // vanishing split IS PASSED IN REVERSE ORDER!!!
    // this is MSM done for h-commitments
{{{H_COMMITMENTS}}}

    // left and s_g2
    // right and g2
    // g2 is not negated as final_exponentiation is doing negation
    let g2 = generatorG2

{{{GWC19_MSM}}}

    let ml_l = miller_loop(el, g2_const)
    let ml_r = miller_loop(er, g2)

    final_exponentiation(ml_l, ml_r)
}

// this test generates random input data for verifier
test check_valid_proof_valid_public_inputs() {
    expect {{{TEST_VALID_PROOF_VALID_INPUTS}}} == True
}

test check_proof_invalid_publuc_inputs(){
    expect {{{TEST_VALID_PROOF_INVALID_INPUTS}}} == False
}

test check_invalid_proof_invalid_publuc_inputs(){
    expect {{{TEST_INVALID_PROOF_INVALID_INPUTS}}} == False
}

test check_valid_proof_tricvial_public_inputs() {
    expect {{{TEST_VALID_PROOF_TRIVIAL_INPUTS}}} == False
}

test check_valid_proof_invalid_transcript_rep() {
    expect {{{TEST_VALID_PROOF_INVALID_TRANSCRIPT_REP}}} == False
}
